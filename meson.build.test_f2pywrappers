project('CellConstructor',
  ['c','fortran'],
  version: '1.5.0',
  license: 'GPL',
  default_options : [
        'warning_level=1',
        'buildtype=release',
        'fortran_args=-O2',
        'fortran_args=-cpp'
    ]
    )

# --- System and Python Dependencies ---
# Encuentra las instalaciones necesarias
py = import('python').find_installation(pure: false)
py_dep = py.dependency()
fc = meson.get_compiler('fortran')

# Dependencias adicionales
#mpi_dep = dependency('mpi')
# Las librerías LAPACK y BLAS son esenciales para las operaciones matriciales de Fortran.
lapack_dep = dependency('lapack')
blas_dep = dependency('blas')
openblas_dep = dependency('openblas', required: false)

# --- MPI Detection ---
# This overrides the logic in os.environ["MPICC"] and os.popen("%s -show" % mpicc).
# Meson has a built-in MPI module.
mpi_args = []
mpi_link_args = []
mpi_compile_args = []
has_mpi = false

# Attempts to find the MPI dependency.
# You can specify a specific MPI compiler with the 'mpi_compiler' parameter
# or, if you want, a specific Fortran compiler with 'mpi_fortran_compiler'.
# For OpenMPI, IntelMPI, MPICH, etc., Meson usually finds it automatically.
#mpi_dep = dependency('mpi', required: false, language: ['c', 'fortran'])
mpi_dep = dependency('mpi', required: false)

if mpi_dep.found()
  message('MPI environment detected correctly.')
  has_mpi = true
  # Meson handles adding appropriate flags. We just add the define.
  # If you need specific MPI flags beyond what Meson adds automatically,
  # you can get them via mpi_dep.get_compile_args() and mpi_dep.get_link_args()
  # and add them to extra_compile_args/extra_link_args.
  mpi_compile_args += ['-D_MPI']
else
  # Here you can add warning logic if MPI is not found.
  # Meson prints a warning if required: true and it is not found.
  # For required: false, you can print your own warning.
  warning('No MPI compiler found, please ensure MPI is installed and configured.')
  warning('If you wish to activate MPI acceleration, consider setting MPICC environment variable or providing Meson with appropriate flags.')
endif
# Busca la librería quadmath, si está disponible
quadmath_dep = fc.find_library('quadmath', required: false)

# --- CONFIGURACIÓN DE NUMPY ---
# Obtiene la ruta de los directorios de cabecera de NumPy y f2py usando el comando de Python
incdir_numpy = run_command(py,
    ['-c', 'import numpy; print(numpy.get_include())'],
    check : true
).stdout().strip()

# f2py también requiere la cabecera fortranobject.h
incdir_f2py = run_command(py,
    ['-c', 'import numpy.f2py; print(numpy.f2py.get_include())'],
    check : true
).stdout().strip()

inc_np = include_directories(incdir_numpy, incdir_f2py)
# --- FIN DE LA CONFIGURACIÓN DE NUMPY ---
#if openblas_dep.found()
#  message('openblas environment detected correctly.')
#  list_dep = [py_dep, mpi_dep, quadmath_dep, openblas_dep, lapack_dep]
#else
#  warning('No openblas found.')
  list_dep = [py_dep, mpi_dep, quadmath_dep, lapack_dep]
#endif
# --- Definición de cada extensión de Python (Fortran) ---

fortranobject_c = incdir_f2py / 'fortranobject.c'

# Extensión 'symph'

# Compilación del módulo Fortran: symph
fortran_sources_symph = [
    'FModules/constants.f90',
    'FModules/error_handler.f90',
    'FModules/get_latvec.f90',
    'FModules/io_global.f90',
    'FModules/rotate_and_add_dyn.f90',
    'FModules/smallgq.f90',
    'FModules/symm_matrix.f90',
    'FModules/contract_two_phonon_propagator.f90',
    'FModules/fc_supercell_from_dyn.f90',
    'FModules/get_q_grid_fast.f90',
    'FModules/kind.f90',
    'FModules/star_q.f90',
    'FModules/symvector.f90',
    'FModules/cryst_to_car.f90',
    'FModules/flush_unit.f90',
    'FModules/get_translations.f90',
    'FModules/q2qstar_out.f90',
    'FModules/set_asr.f90',
    'FModules/symdynph_gq_new.f90',
    'FModules/trntnsc.f90',
    'FModules/eff_charge_interp.f90',
    'FModules/from_matdyn.f90',
    'FModules/interp.f90',
    'FModules/q_gen.f90',
    'FModules/set_tau.f90',
    'FModules/symm_base.f90',
    'FModules/unwrap_tensors.f90',
    'FModules/eqvect.f90',
    'FModules/get_equivalent_atoms.f90',
    'FModules/invmat.f90',
    'FModules/recips.f90',
    'FModules/sgam_ph.f90',
    'FModules/symmetry_high_rank.f90'
]

fortran_wrappers_symph = [
  'f2py_wrappers/symph-f2pywrappers.f',
  'f2py_wrappers/symph-f2pywrappers2.f90',
  'f2py_wrappers/thirdordermodule.c'
]

fortran_src_symph = fortran_sources_symph + fortran_wrappers_symph

py.extension_module('symph',
    fortran_src_symph,
    include_directories: inc_np,
    dependencies: list_dep,
    install: true
)

# Extensión 'secondorder'

# Compilación del módulo Fortran: secondorder
fortran_sources_secondorder = [
    'FModules/second_order_centering.f90',
    'FModules/second_order_ASR.f90'
]

fortran_wrappers_secondorder = [
  'f2py_wrappers/secondorder-f2pywrappers2.f90',
  'f2py_wrappers/secondordermodule.c'
]

fortran_src_secondorder = fortran_sources_secondorder + fortran_wrappers_secondorder

py.extension_module('secondorder',
    fortran_src_secondorder,
    include_directories: inc_np,
    dependencies: list_dep,
    install: true
)

# Extensión 'thirdorder'

# Compilación del módulo Fortran: thirdorder

fortran_sources_thirdorder = [
    'FModules/third_order_ASR.f90',
    'FModules/third_order_centering.f90',
    'FModules/third_order_cond_centering.f90',
    'FModules/third_order_cond.f90',
    'FModules/third_order_dynbubble.f90',
    'FModules/third_order_interpol.f90'
]

fortran_wrappers_thirdorder = [
  'f2py_wrappers/thirdordermodule.c',
  'f2py_wrappers/thirdorder-f2pywrappers2.f90'
]

fortran_src_thirdorder = fortran_sources_thirdorder + fortran_wrappers_thirdorder

py.extension_module('thirdorder',
    fortran_src_thirdorder,
    include_directories: inc_np,
    dependencies: list_dep,
    install: true
)

# Extensión 'thermal_conductivity'

fortran_sources_thermal_conductivity = [
'FModules/get_lf.f90',
'FModules/get_scattering_q_grid.f90',
'FModules/third_order_centering.f90',
'FModules/third_order_cond.f90'
]

fortran_wrappers_thermal_conductivity = [
  'f2py_wrappers/thermal_conductivity-f2pywrappers2.f90',
  'f2py_wrappers/thermal_conductivitymodule.c'
]

fortran_src_thermal_conductivity = fortran_sources_thermal_conductivity + fortran_wrappers_thermal_conductivity

py.extension_module('thermal_conductivity',
    fortran_src_thermal_conductivity,
    include_directories: inc_np,
    dependencies: list_dep,
    install: true
)

# --- Definición de la extensión C 'cc_linalg' ---
wrapper_file = ''
if py.version().version_compare('<3.0')
  wrapper_file = 'CModules/wrapper.c'
else
  wrapper_file = 'CModules/wrapper3.c'
endif

# Compilación del módulo C: cc_linalg
c_linalg_sources = [
    'CModules/LinAlg.c',
    wrapper_file
]

py.extension_module('cc_linalg',
    c_linalg_sources,
    include_directories: inc_np, # Se añade la cabecera de NumPy para el módulo de C
    dependencies: py_dep,
    install: true
)


# --- Instalación del paquete de Python 'cellconstructor' ---
install_data(
  'cellconstructor/__init__.py', 'cellconstructor/AnharmonicForceFields.py', 'cellconstructor/calculators.py',
  'cellconstructor/Methods.py', 'cellconstructor/Phonons.py', 'cellconstructor/Spectral.py',
  'cellconstructor/ThermalConductivity.py', 'cellconstructor/Units.py', 'cellconstructor/Bands.py',
  'cellconstructor/ForceTensor.py', 'cellconstructor/Manipulate.py', 'cellconstructor/Moro_object.py',
  'cellconstructor/Settings.py', 'cellconstructor/Structure.py', 'cellconstructor/symmetries.py',
  'cellconstructor/Timer.py',
  install_dir: py.get_install_dir() / 'cellconstructor',
)

install_data(
  'cellconstructor/SymData/15.dat', 'cellconstructor/SymData/36_red.dat', 'cellconstructor/SymData/36.dat',
  'cellconstructor/SymData/60.dat', 'cellconstructor/SymData/64.bcs', 'cellconstructor/SymData/64.dat',
  'cellconstructor/SymData/convert_sym.py',
  install_dir: py.get_install_dir() / 'cellconstructor' / 'SymData'
)

# --- Instalación de los scripts ejecutables ---
py.install_sources([
  'scripts/symmetrize_dynmat.py',
  'scripts/cellconstructor_test.py',
  'scripts/view_scf_atoms.py'
])

# Set the tests by pytest.
pytest_exe = find_program('pytest', required: false)

if pytest_exe.found()
  test('pytest', pytest_exe,
    args : ['-v'],
    workdir : meson.project_source_root()
  )
else
  message('pytest no encontrado; se omiten tests con pytest.')
endif
